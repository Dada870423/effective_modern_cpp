## 條款一：認識樣板型別推導

通常，一般使用function template使用情形如下(pseudo code)

    template <typename T>
    void f(ParaType param);

而使用方式如下

    f(expr)

而expr和ParaType的型態不一定會相同，舉例來說

---
    template <typename T>
    void f(T& i);   // ParaType型態為const int&
                    // T推導之型態為const int
    ...
    
    const int num = 5;
    f(num);     // num型態為int

變數num在宣告時型態為const int，而ParaType型態為const int&。

---
template型別推導的結果可以分為以下三種情況
1. ParamType為參考或是指標，但不是universal reference
2. ParamType為universal reference(universal reference定義參見條款24)
3. ParamType不為參考或是指標

### 狀況一、ParamType為參考或指標
1. 若ParamType是參考，則忽略參考的部分
2. expr和ParamType做比對後可得到T之型態

e.g.

    template <typename T>
    void f(T&)

    template <typename T>
    void g(const T&)

    ...

    int num1 = 5;
    int& num2 = num1;
    const int num3 = num1;
    const int& num4 = num1;

    f(num1);    // T為int，ParamType為int&
    f(num2);    // T為int，ParamType為int&
    f(num3);    // T為const int，ParamType為const int&
    f(num4);    // T為const int，ParamType為const int&

    g(num1);    // T為const int，ParamType為const int&
    g(num2);    // T為const int，ParamType為const int&
    g(num3);    // T為const int，ParamType為const int&
    g(num4);    // T為const int，ParamType為const int&

### 狀況二、