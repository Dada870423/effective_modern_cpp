## 條款一：認識樣板型別推導

通常，一般使用function template使用情形如下(pseudo code)

```cpp
template <typename T>
void f(ParaType param);
```

而使用方式如下

```cpp
f(expr)
```

而expr和ParaType的型態不一定會相同，舉例來說

```cpp
template <typename T>
void f(T& i);   // ParaType型態為const int&
                // T推導之型態為const int
...

const int num = 5;
f(num);     // num型態為int
```

變數num在宣告時型態為const int，而ParaType型態為const int&。

---
template型別推導的結果可以分為以下三種情況
1. ParamType為參考或是指標，但不是universal reference
2. ParamType為universal reference(universal reference定義參見條款24)
3. ParamType不為參考或是指標

### 狀況一、ParamType為參考或指標
1. 若ParamType是參考，則忽略參考的部分
2. expr和ParamType做比對後可得到T之型態

e.g.

```cpp
template <typename T>
void f(T&)

template <typename T>
void g(const T&)

...

int num1 = 5;
int& num2 = num1;
const int num3 = num1;
const int& num4 = num1;

f(num1);    // T為int，ParamType為int&
f(num2);    // T為int，ParamType為int&
f(num3);    // T為const int，ParamType為const int&
f(num4);    // T為const int，ParamType為const int&

g(num1);    // T為const int，ParamType為const int&
g(num2);    // T為const int，ParamType為const int&
g(num3);    // T為const int，ParamType為const int&
g(num4);    // T為const int，ParamType為const int&
```

### 狀況二、ParamType是Universal Reference
&emsp;&emsp;Universal Reference可參考條款24，目前只需要知道有其存在，且與rvalue及lvalue皆不同即可。
&emsp;&emsp;若是傳入參數樣是為T之樣板，Universal reference宣告型別為&&，推導型別規則如下

1. 若為lvalue，則T及ParamType皆為lvalue參考
2. 若為rvalue，則採用一般的推導規則

e.g.

```cpp
template<typename T>
void f(T&& param);

int a = 10;
int& b = a;
const int c = a;
const& int d = a;

f(a);   // T、ParamType為int&
f(b);   // T、ParamType為int&
f(c);   // T、ParamType為const int&
f(d);   // T、ParamType為const int&
f(20);  // // T為int，ParamType為int&&
```