搬移語意是C++11後一個顯為人知的功能，我們常會覺得搬移語意是那麼的快速且有效節省機翼體空間，就只是將物件的指標更換而已，物件的內容並沒有做任何的更動，但是並不是所有情況使用搬移語意都比複製語意更加快速的。

在條款17中有提到，若是物件宣告時有宣告copy操作子、move操作子或是解構子的話，那麼move操作子就不會自動生成，這樣會使得舊有的C++11前的程式碼無法使用move的好處。

而就算物件可以使用move操作，也不能代表得到的好處是符合預期的。即使是STL容器也是一樣，容器使用move操作後無法有預期的效果可以歸類為兩點
1. 容器本身不支援成本較低的搬移方式
2. 容器內的元素無法滿足搬移的要求

e.g.<br>
一般的容器搬移操作如下
![](https://i.imgur.com/n6weoty.png)

通常都會有一個指標指向該容器，而只要更改指向容器的指標即可達成move功能

但是像是std::array則沒有這種指標
![](https://i.imgur.com/cnZoHci.png)

所以若std::array要搬移到另一個std::array，就必須要線性的為每個元素進行搬移，雖然仍然是搬移，但是跟原本只需要更改一個指標比起來，std::array就需要更改所有元素的指標，和原本預期改善的效能降低不少。更甚者，如果容器內元素也不支援搬移，那就只能採用線性複製的方式。

而std::string在字串較短(小於15個字元)時，會採用小字串最佳化(small string optimization，SSO)的方式，在使用短字串時，會將字串存在buffer中而非heap中，如此使得無法使用更改指標方式改善效能，變得只能使用複製。

不過使用SSO方式處理短字串仍然有優勢，因為根據統計大部分使用字串時都是使用短字串，短字串的空間buffer還尚能應付，所以若要重複存取這些短字串，是有效能上的優勢的，而且，與其說move沒有比copy效能好，倒不如說copy和move效能一樣好。

再進一步來說，即使有提供搬移語意，實際使用搬移時也可能不會使用搬移而是使用複製，例如std::vector提供的push_back為了避免在搬移物件時發生搬移到一半突然發生例外而導致資料完整度產生問題，所以push_back的物件的搬移語意必須是noexcept，push_back才會執行搬移語意(在條款14中有提到)。

所以總結來說，有幾種情況是C++11的搬移語意不會帶來比copy好的效能的
1. 沒有定義或自動產生move操作子
2. 搬移沒有比較好
3. 無法使用搬移(支援搬移，但是在某些情況使用搬移的限制較嚴格，沒有使用noexcept導致搬移沒有執行)

而回到本條款的主題，在轉寫泛型程式時，是無法知道使用者使用的物件是否支援搬移操作，所以此時使用較保險的複製操作是比較好的(所以需要"假設"搬移操作不存在，其操作成本也沒有較低)。而若在開發時可以得知是否物件能支援搬移操作，就能夠使用搬移語意達到比較好的效能。