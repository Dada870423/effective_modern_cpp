原始指標(raw pointer)通常都不是很讓人喜歡，通常有以下幾個原因，每個環節都需要確保沒有出錯

1. 單看其宣告式無法得知其為單一物件或是陣列
e.g. int* 到底是指向一個int的指標，或是指向int陣列？
2. 宣告內容的物件並無法得知其是否應該要清出物件，也不知道指標是否擁有該物件，若擁有該物件，在清除指標時就需要清除該物件
3. 無法得知清除物件的方式，是要使用delete或是其他方式？
4. 即使知道要使用delete，要清除一個單一物件(delete)和清除一個陣列(delete[])行為是不同的
5. 即使知道要清除單一物件或是陣列，需要非常小心才能確保每個物件都只會被清除一次，若沒有清除乾淨會造成資源洩漏，若有物件被清除兩次以上，在第二次清除時就會產生未定義行為
6. 一般而言無法得知指標是否為dangling pointer，也就是指標指向的物件已經被刪除無法再被使用

由於原始指標是這麼容易出錯，智慧型指標就是為了改善原始指標的這些問題產生而來的方法，其包覆原始指標，並改善其缺點，如果可以，應該要盡可能使用智慧型指標，其可以做到幾乎所有原始指標能做到的行為，但是錯誤率卻會大大降低。

目前智慧型指標有四種，其中一種是C++98遺留下來的std::auto_ptr，是唯一可以支援C++11之前的智慧型指標，不會也因為這樣其不支援move語意，也會產生許多不合理的行為(e.g.複製std::auto_ptr時會設為null)，所以如果可以，盡量使用本節介紹的其餘三種智慧型指標。